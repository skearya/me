import { readFileSync, writeFileSync } from "node:fs";

const key = `: /`;

const albums = JSON.parse(
	readFileSync("lastfm-getTopAlbums-response.json", "utf-8"),
);

export type TopAlbum = {
	name: string;
	artist: {
		url: string;
		name: string;
		mbid: string;
	};
	image: {
		size: string;
		"#text": string;
	}[];
	url: string;
	playcount: string;
	tags: Tags | undefined;
	published: string | undefined;
	summary: string | undefined;
};

const data: TopAlbum[] = [];

for (const album of albums.topalbums.album) {
	const { artist, image, name, url, playcount, mbid } = album;

	let tags;
	let published;
	let summary;

	if (mbid !== "") {
		const res = (await (
			await fetch(
				"https://ws.audioscrobbler.com/2.0/?" +
					new URLSearchParams({
						method: "album.getinfo",
						api_key: key,
						mbid,
						format: "json",
					}),
			)
		).json()) as AlbumGetInfo;

		tags = res.album.tags;

		if (res.album.wiki) {
			published = res.album.wiki.published;
			summary = res.album.wiki.summary;
		}
	}

	data.push({
		name,
		artist,
		image,
		url,
		playcount,
		tags,
		published,
		summary,
	});

	await new Promise((res) => setTimeout(() => res(null), 500));
}

writeFileSync("../data/2025-albums.json", JSON.stringify(data));

// Autogenerated types

interface AlbumGetInfo {
	album: Album;
}

interface Album {
	artist: string;
	tags: Tags;
	name: string;
	image: Image[];
	tracks: Tracks;
	listeners: string;
	playcount: string;
	url: string;
	wiki: Wiki;
}

interface Wiki {
	published: string;
	summary: string;
	content: string;
}

interface Tracks {
	track: Track[];
}

interface Track {
	streamable: Streamable;
	duration: number;
	url: string;
	name: string;
	"@attr": Attr;
	artist: Artist;
}

interface Artist {
	url: string;
	name: string;
	mbid: string;
}

interface Attr {
	rank: number;
}

interface Streamable {
	fulltrack: string;
	"#text": string;
}

interface Image {
	size: string;
	"#text": string;
}

interface Tags {
	tag: Tag[];
}

interface Tag {
	url: string;
	name: string;
}
